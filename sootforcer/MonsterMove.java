package sootforcer;

import battlecode.common.Direction;
import battlecode.common.MapLocation;
import sootforcer.C;
import sootforcer.M;
import sootforcer.ZoneSquare;

/**
 * Optimized with love. But, due to that, this file is near unreadable, see MonsterMoveReadable for a readable version of the main logic
 * This file is generated by code
 *
 *
 * The idea of the movement system here is simple:
 * Find positions we may want to move to (and can move to)
 * Build a movement vector that contains our ideal line of movement
 * Define a bunch of 'shapes' that determine the evaluation score of these positions, add them here
 * Then let getValuationSlot do the rest.
 *
 * Shapes currently used (because they are useful and cost efficient):
 * Rectangles
 * Angled rectangles
 * Circles
 * 'Vector' Circles
 *
 * In the first 3, the evaluation score is only affected by a simple calculation, if our position is inside of our shape, change the evaluation of the zone by
 * the predefined 'desired' value
 * For vector circles, we also add an extra evaluation based on the distance to the center point of the sphere, but only
 * if we are inside the sphere.  With a negative desire, the unit will prefer running away from the center.
 * Additionally this still has the on/off base desire
 *
 * The total evaluation is also affected by the move vector we defined
 *
 * An example: we've selected an enemy archon as our main target, we pick our move vector towards it
 * There's a lumberjack near that we want to avoid, define a circle centered on the lumberjack with a negative desire
 * this makes us avoid the lumberjack
 * Some bullets are flying towards us, place angled rectangles over them with a negative score
 * We see an enemy gardener, place a vector circle on top of that with both a positive base and a positive distance desire
 * this makes us want to stick within a certain range of the gardener, and makes us want to move in if were close enough
 *
 *
 *
 * Optimization efforts:
 * Battlecode 2017 uses bytecodes used rather than time executed to measure bot performance
 * A tiny amount is available per turn, and the code here, in particular getValuationSlot represents the critical path
 *
 * Bytecode-based performance is often weird, which demands some rather strange solutions. The following are particularly relevant for the
 * optimization done in this file:
 *
 * Switch-cases are constant in bytecode-time and fall-through cases are free. This means a simple loop:    for(int i=0; i < someVal; i++){doSomething(i);}
 * can be more efficiently coded using a switch case:   switch(doSomething){ case 100: doSomething(100)  case 99: doSomething(99)  case 98: doSomething(98) ....  }
 * as long as someVal never exceeds the highest named case.  This method avoids all loop overhead: changing the iterator, comparing it to someVal and calling a goto
 *
 * Static variables are cheaper to access than class variables in bytecode-time
 *
 * It's cheaper to access a value than it is to access a member of an array. This can be combined with the switch-case
 * trick to store data normally stored in an array by just listing out all the variables and accessing these directly
 *
 * Some battlecode-api functions like    position.isWithinDistance(position2,distance)  are cheaper than manually calculating the same yourself
 *
 * Hilariously, some of the functions in std library Float, Integer, Math are cheaper in terms of bytecode than using operators
 * in battlecodes method of measuring executed bytecode.    a = Float.sum(c,b);  is one bytecode cheaper than  a = b + c;
 *
 * The rest is a matter of not assigning to variables when not neccessary, precalculating what can be calculated and other simple optimization tricks

 */


    public class MonsterMove extends sootforcer.M {

    //Adds an angled rectangle based on a starting point and direction, used to avoid bullets
    public static void addAngledRectangle(MapLocation start, Direction dir, MapLocation end, float avoidwidth, float desire, float speed) {
        Direction left;
        MapLocation leftStart;
        MapLocation leftEnd;
        MapLocation rightEnd;
        float x1;
        float y1;
        switch (angledRectangleCount) {
            case 0:
                left = dir.rotateLeftDegrees(90);
                leftStart = start.subtract(dir, avoidwidth).add(left, avoidwidth);
                leftEnd = end.add(dir, avoidwidth).add(left, avoidwidth);
                rightEnd = leftEnd.subtract(left, Float.sum(avoidwidth, avoidwidth));
                x1 = -leftEnd.x;
                y1 = -leftEnd.y;
                Z1_p21x = Float.sum(rightEnd.x, x1);
                Z1_p21y = Float.sum(rightEnd.y, y1);
                Z1_p41x = Float.sum(leftStart.x, x1);
                Z1_p41y = Float.sum(leftStart.y, y1);
                Z1_dotsection2 = -Float.sum(x1 * Z1_p21x, y1 * Z1_p21y);
                Z1_dotsection4 = -Float.sum(x1 * Z1_p41x, y1 * Z1_p41y);
                Z1_p21MagSquared = Float.sum(Z1_dotsection2, Float.sum(Z1_p21x * Z1_p21x, Z1_p21y * Z1_p21y));
                Z1_p41MagSquared = Float.sum(Z1_dotsection4, Float.sum(Z1_p41x * Z1_p41x, Z1_p41y * Z1_p41y));
                Z1_desire = desire;
                Z1_center = start.add(dir, speed * 0.5f);
                Z1_maxdist = Z1_center.distanceTo(leftStart);
                angledRectangleCount++;
                break;
            case 1:
                left = dir.rotateLeftDegrees(90);
                leftStart = start.subtract(dir, avoidwidth).add(left, avoidwidth);
                leftEnd = end.add(dir, avoidwidth).add(left, avoidwidth);
                rightEnd = leftEnd.subtract(left, Float.sum(avoidwidth, avoidwidth));
                x1 = -leftEnd.x;
                y1 = -leftEnd.y;
                Z2_p21x = Float.sum(rightEnd.x, x1);
                Z2_p21y = Float.sum(rightEnd.y, y1);
                Z2_p41x = Float.sum(leftStart.x, x1);
                Z2_p41y = Float.sum(leftStart.y, y1);
                Z2_dotsection2 = -Float.sum(x1 * Z2_p21x, y1 * Z2_p21y);
                Z2_dotsection4 = -Float.sum(x1 * Z2_p41x, y1 * Z2_p41y);
                Z2_p21MagSquared = Float.sum(Z2_dotsection2, Float.sum(Z2_p21x * Z2_p21x, Z2_p21y * Z2_p21y));
                Z2_p41MagSquared = Float.sum(Z2_dotsection4, Float.sum(Z2_p41x * Z2_p41x, Z2_p41y * Z2_p41y));
                Z2_desire = desire;
                Z2_center = start.add(dir, speed * 0.5f);
                Z2_maxdist = Z2_center.distanceTo(leftStart);
                angledRectangleCount++;
                break;
            case 2:
                left = dir.rotateLeftDegrees(90);
                leftStart = start.subtract(dir, avoidwidth).add(left, avoidwidth);
                leftEnd = end.add(dir, avoidwidth).add(left, avoidwidth);
                rightEnd = leftEnd.subtract(left, Float.sum(avoidwidth, avoidwidth));
                x1 = -leftEnd.x;
                y1 = -leftEnd.y;
                Z3_p21x = Float.sum(rightEnd.x, x1);
                Z3_p21y = Float.sum(rightEnd.y, y1);
                Z3_p41x = Float.sum(leftStart.x, x1);
                Z3_p41y = Float.sum(leftStart.y, y1);
                Z3_dotsection2 = -Float.sum(x1 * Z3_p21x, y1 * Z3_p21y);
                Z3_dotsection4 = -Float.sum(x1 * Z3_p41x, y1 * Z3_p41y);
                Z3_p21MagSquared = Float.sum(Z3_dotsection2, Float.sum(Z3_p21x * Z3_p21x, Z3_p21y * Z3_p21y));
                Z3_p41MagSquared = Float.sum(Z3_dotsection4, Float.sum(Z3_p41x * Z3_p41x, Z3_p41y * Z3_p41y));
                Z3_desire = desire;
                Z3_center = start.add(dir, speed * 0.5f);
                Z3_maxdist = Z3_center.distanceTo(leftStart);
                angledRectangleCount++;
                break;
            case 3:
                left = dir.rotateLeftDegrees(90);
                leftStart = start.subtract(dir, avoidwidth).add(left, avoidwidth);
                leftEnd = end.add(dir, avoidwidth).add(left, avoidwidth);
                rightEnd = leftEnd.subtract(left, Float.sum(avoidwidth, avoidwidth));
                x1 = -leftEnd.x;
                y1 = -leftEnd.y;
                Z4_p21x = Float.sum(rightEnd.x, x1);
                Z4_p21y = Float.sum(rightEnd.y, y1);
                Z4_p41x = Float.sum(leftStart.x, x1);
                Z4_p41y = Float.sum(leftStart.y, y1);
                Z4_dotsection2 = -Float.sum(x1 * Z4_p21x, y1 * Z4_p21y);
                Z4_dotsection4 = -Float.sum(x1 * Z4_p41x, y1 * Z4_p41y);
                Z4_p21MagSquared = Float.sum(Z4_dotsection2, Float.sum(Z4_p21x * Z4_p21x, Z4_p21y * Z4_p21y));
                Z4_p41MagSquared = Float.sum(Z4_dotsection4, Float.sum(Z4_p41x * Z4_p41x, Z4_p41y * Z4_p41y));
                Z4_desire = desire;
                Z4_center = start.add(dir, speed * 0.5f);
                Z4_maxdist = Z4_center.distanceTo(leftStart);
                angledRectangleCount++;
                break;
            case 4:
                left = dir.rotateLeftDegrees(90);
                leftStart = start.subtract(dir, avoidwidth).add(left, avoidwidth);
                leftEnd = end.add(dir, avoidwidth).add(left, avoidwidth);
                rightEnd = leftEnd.subtract(left, Float.sum(avoidwidth, avoidwidth));
                x1 = -leftEnd.x;
                y1 = -leftEnd.y;
                Z5_p21x = Float.sum(rightEnd.x, x1);
                Z5_p21y = Float.sum(rightEnd.y, y1);
                Z5_p41x = Float.sum(leftStart.x, x1);
                Z5_p41y = Float.sum(leftStart.y, y1);
                Z5_dotsection2 = -Float.sum(x1 * Z5_p21x, y1 * Z5_p21y);
                Z5_dotsection4 = -Float.sum(x1 * Z5_p41x, y1 * Z5_p41y);
                Z5_p21MagSquared = Float.sum(Z5_dotsection2, Float.sum(Z5_p21x * Z5_p21x, Z5_p21y * Z5_p21y));
                Z5_p41MagSquared = Float.sum(Z5_dotsection4, Float.sum(Z5_p41x * Z5_p41x, Z5_p41y * Z5_p41y));
                Z5_desire = desire;
                Z5_center = start.add(dir, speed * 0.5f);
                Z5_maxdist = Z5_center.distanceTo(leftStart);
                angledRectangleCount++;
                break;
            case 5:
                left = dir.rotateLeftDegrees(90);
                leftStart = start.subtract(dir, avoidwidth).add(left, avoidwidth);
                leftEnd = end.add(dir, avoidwidth).add(left, avoidwidth);
                rightEnd = leftEnd.subtract(left, Float.sum(avoidwidth, avoidwidth));
                x1 = -leftEnd.x;
                y1 = -leftEnd.y;
                Z6_p21x = Float.sum(rightEnd.x, x1);
                Z6_p21y = Float.sum(rightEnd.y, y1);
                Z6_p41x = Float.sum(leftStart.x, x1);
                Z6_p41y = Float.sum(leftStart.y, y1);
                Z6_dotsection2 = -Float.sum(x1 * Z6_p21x, y1 * Z6_p21y);
                Z6_dotsection4 = -Float.sum(x1 * Z6_p41x, y1 * Z6_p41y);
                Z6_p21MagSquared = Float.sum(Z6_dotsection2, Float.sum(Z6_p21x * Z6_p21x, Z6_p21y * Z6_p21y));
                Z6_p41MagSquared = Float.sum(Z6_dotsection4, Float.sum(Z6_p41x * Z6_p41x, Z6_p41y * Z6_p41y));
                Z6_desire = desire;
                Z6_center = start.add(dir, speed * 0.5f);
                Z6_maxdist = Z6_center.distanceTo(leftStart);
                angledRectangleCount++;
                break;
            case 6:
                left = dir.rotateLeftDegrees(90);
                leftStart = start.subtract(dir, avoidwidth).add(left, avoidwidth);
                leftEnd = end.add(dir, avoidwidth).add(left, avoidwidth);
                rightEnd = leftEnd.subtract(left, Float.sum(avoidwidth, avoidwidth));
                x1 = -leftEnd.x;
                y1 = -leftEnd.y;
                Z7_p21x = Float.sum(rightEnd.x, x1);
                Z7_p21y = Float.sum(rightEnd.y, y1);
                Z7_p41x = Float.sum(leftStart.x, x1);
                Z7_p41y = Float.sum(leftStart.y, y1);
                Z7_dotsection2 = -Float.sum(x1 * Z7_p21x, y1 * Z7_p21y);
                Z7_dotsection4 = -Float.sum(x1 * Z7_p41x, y1 * Z7_p41y);
                Z7_p21MagSquared = Float.sum(Z7_dotsection2, Float.sum(Z7_p21x * Z7_p21x, Z7_p21y * Z7_p21y));
                Z7_p41MagSquared = Float.sum(Z7_dotsection4, Float.sum(Z7_p41x * Z7_p41x, Z7_p41y * Z7_p41y));
                Z7_desire = desire;
                Z7_center = start.add(dir, speed * 0.5f);
                Z7_maxdist = Z7_center.distanceTo(leftStart);
                angledRectangleCount++;
                break;
            case 7:
                left = dir.rotateLeftDegrees(90);
                leftStart = start.subtract(dir, avoidwidth).add(left, avoidwidth);
                leftEnd = end.add(dir, avoidwidth).add(left, avoidwidth);
                rightEnd = leftEnd.subtract(left, Float.sum(avoidwidth, avoidwidth));
                x1 = -leftEnd.x;
                y1 = -leftEnd.y;
                Z8_p21x = Float.sum(rightEnd.x, x1);
                Z8_p21y = Float.sum(rightEnd.y, y1);
                Z8_p41x = Float.sum(leftStart.x, x1);
                Z8_p41y = Float.sum(leftStart.y, y1);
                Z8_dotsection2 = -Float.sum(x1 * Z8_p21x, y1 * Z8_p21y);
                Z8_dotsection4 = -Float.sum(x1 * Z8_p41x, y1 * Z8_p41y);
                Z8_p21MagSquared = Float.sum(Z8_dotsection2, Float.sum(Z8_p21x * Z8_p21x, Z8_p21y * Z8_p21y));
                Z8_p41MagSquared = Float.sum(Z8_dotsection4, Float.sum(Z8_p41x * Z8_p41x, Z8_p41y * Z8_p41y));
                Z8_desire = desire;
                Z8_center = start.add(dir, speed * 0.5f);
                Z8_maxdist = Z8_center.distanceTo(leftStart);
                angledRectangleCount++;
                break;
            case 8:
                left = dir.rotateLeftDegrees(90);
                leftStart = start.subtract(dir, avoidwidth).add(left, avoidwidth);
                leftEnd = end.add(dir, avoidwidth).add(left, avoidwidth);
                rightEnd = leftEnd.subtract(left, Float.sum(avoidwidth, avoidwidth));
                x1 = -leftEnd.x;
                y1 = -leftEnd.y;
                Z9_p21x = Float.sum(rightEnd.x, x1);
                Z9_p21y = Float.sum(rightEnd.y, y1);
                Z9_p41x = Float.sum(leftStart.x, x1);
                Z9_p41y = Float.sum(leftStart.y, y1);
                Z9_dotsection2 = -Float.sum(x1 * Z9_p21x, y1 * Z9_p21y);
                Z9_dotsection4 = -Float.sum(x1 * Z9_p41x, y1 * Z9_p41y);
                Z9_p21MagSquared = Float.sum(Z9_dotsection2, Float.sum(Z9_p21x * Z9_p21x, Z9_p21y * Z9_p21y));
                Z9_p41MagSquared = Float.sum(Z9_dotsection4, Float.sum(Z9_p41x * Z9_p41x, Z9_p41y * Z9_p41y));
                Z9_desire = desire;
                Z9_center = start.add(dir, speed * 0.5f);
                Z9_maxdist = Z9_center.distanceTo(leftStart);
                angledRectangleCount++;
                break;
            case 9:
                left = dir.rotateLeftDegrees(90);
                leftStart = start.subtract(dir, avoidwidth).add(left, avoidwidth);
                leftEnd = end.add(dir, avoidwidth).add(left, avoidwidth);
                rightEnd = leftEnd.subtract(left, Float.sum(avoidwidth, avoidwidth));
                x1 = -leftEnd.x;
                y1 = -leftEnd.y;
                Z10_p21x = Float.sum(rightEnd.x, x1);
                Z10_p21y = Float.sum(rightEnd.y, y1);
                Z10_p41x = Float.sum(leftStart.x, x1);
                Z10_p41y = Float.sum(leftStart.y, y1);
                Z10_dotsection2 = -Float.sum(x1 * Z10_p21x, y1 * Z10_p21y);
                Z10_dotsection4 = -Float.sum(x1 * Z10_p41x, y1 * Z10_p41y);
                Z10_p21MagSquared = Float.sum(Z10_dotsection2, Float.sum(Z10_p21x * Z10_p21x, Z10_p21y * Z10_p21y));
                Z10_p41MagSquared = Float.sum(Z10_dotsection4, Float.sum(Z10_p41x * Z10_p41x, Z10_p41y * Z10_p41y));
                Z10_desire = desire;
                Z10_center = start.add(dir, speed * 0.5f);
                Z10_maxdist = Z10_center.distanceTo(leftStart);
                angledRectangleCount++;
                break;
            case 10:
                left = dir.rotateLeftDegrees(90);
                leftStart = start.subtract(dir, avoidwidth).add(left, avoidwidth);
                leftEnd = end.add(dir, avoidwidth).add(left, avoidwidth);
                rightEnd = leftEnd.subtract(left, Float.sum(avoidwidth, avoidwidth));
                x1 = -leftEnd.x;
                y1 = -leftEnd.y;
                Z11_p21x = Float.sum(rightEnd.x, x1);
                Z11_p21y = Float.sum(rightEnd.y, y1);
                Z11_p41x = Float.sum(leftStart.x, x1);
                Z11_p41y = Float.sum(leftStart.y, y1);
                Z11_dotsection2 = -Float.sum(x1 * Z11_p21x, y1 * Z11_p21y);
                Z11_dotsection4 = -Float.sum(x1 * Z11_p41x, y1 * Z11_p41y);
                Z11_p21MagSquared = Float.sum(Z11_dotsection2, Float.sum(Z11_p21x * Z11_p21x, Z11_p21y * Z11_p21y));
                Z11_p41MagSquared = Float.sum(Z11_dotsection4, Float.sum(Z11_p41x * Z11_p41x, Z11_p41y * Z11_p41y));
                Z11_desire = desire;
                Z11_center = start.add(dir, speed * 0.5f);
                Z11_maxdist = Z11_center.distanceTo(leftStart);
                angledRectangleCount++;
                break;
            case 11:
                left = dir.rotateLeftDegrees(90);
                leftStart = start.subtract(dir, avoidwidth).add(left, avoidwidth);
                leftEnd = end.add(dir, avoidwidth).add(left, avoidwidth);
                rightEnd = leftEnd.subtract(left, Float.sum(avoidwidth, avoidwidth));
                x1 = -leftEnd.x;
                y1 = -leftEnd.y;
                Z12_p21x = Float.sum(rightEnd.x, x1);
                Z12_p21y = Float.sum(rightEnd.y, y1);
                Z12_p41x = Float.sum(leftStart.x, x1);
                Z12_p41y = Float.sum(leftStart.y, y1);
                Z12_dotsection2 = -Float.sum(x1 * Z12_p21x, y1 * Z12_p21y);
                Z12_dotsection4 = -Float.sum(x1 * Z12_p41x, y1 * Z12_p41y);
                Z12_p21MagSquared = Float.sum(Z12_dotsection2, Float.sum(Z12_p21x * Z12_p21x, Z12_p21y * Z12_p21y));
                Z12_p41MagSquared = Float.sum(Z12_dotsection4, Float.sum(Z12_p41x * Z12_p41x, Z12_p41y * Z12_p41y));
                Z12_desire = desire;
                Z12_center = start.add(dir, speed * 0.5f);
                Z12_maxdist = Z12_center.distanceTo(leftStart);
                angledRectangleCount++;
                break;
            case 12:
                left = dir.rotateLeftDegrees(90);
                leftStart = start.subtract(dir, avoidwidth).add(left, avoidwidth);
                leftEnd = end.add(dir, avoidwidth).add(left, avoidwidth);
                rightEnd = leftEnd.subtract(left, Float.sum(avoidwidth, avoidwidth));
                x1 = -leftEnd.x;
                y1 = -leftEnd.y;
                Z13_p21x = Float.sum(rightEnd.x, x1);
                Z13_p21y = Float.sum(rightEnd.y, y1);
                Z13_p41x = Float.sum(leftStart.x, x1);
                Z13_p41y = Float.sum(leftStart.y, y1);
                Z13_dotsection2 = -Float.sum(x1 * Z13_p21x, y1 * Z13_p21y);
                Z13_dotsection4 = -Float.sum(x1 * Z13_p41x, y1 * Z13_p41y);
                Z13_p21MagSquared = Float.sum(Z13_dotsection2, Float.sum(Z13_p21x * Z13_p21x, Z13_p21y * Z13_p21y));
                Z13_p41MagSquared = Float.sum(Z13_dotsection4, Float.sum(Z13_p41x * Z13_p41x, Z13_p41y * Z13_p41y));
                Z13_desire = desire;
                Z13_center = start.add(dir, speed * 0.5f);
                Z13_maxdist = Z13_center.distanceTo(leftStart);
                angledRectangleCount++;
                break;
            case 13:
                left = dir.rotateLeftDegrees(90);
                leftStart = start.subtract(dir, avoidwidth).add(left, avoidwidth);
                leftEnd = end.add(dir, avoidwidth).add(left, avoidwidth);
                rightEnd = leftEnd.subtract(left, Float.sum(avoidwidth, avoidwidth));
                x1 = -leftEnd.x;
                y1 = -leftEnd.y;
                Z14_p21x = Float.sum(rightEnd.x, x1);
                Z14_p21y = Float.sum(rightEnd.y, y1);
                Z14_p41x = Float.sum(leftStart.x, x1);
                Z14_p41y = Float.sum(leftStart.y, y1);
                Z14_dotsection2 = -Float.sum(x1 * Z14_p21x, y1 * Z14_p21y);
                Z14_dotsection4 = -Float.sum(x1 * Z14_p41x, y1 * Z14_p41y);
                Z14_p21MagSquared = Float.sum(Z14_dotsection2, Float.sum(Z14_p21x * Z14_p21x, Z14_p21y * Z14_p21y));
                Z14_p41MagSquared = Float.sum(Z14_dotsection4, Float.sum(Z14_p41x * Z14_p41x, Z14_p41y * Z14_p41y));
                Z14_desire = desire;
                Z14_center = start.add(dir, speed * 0.5f);
                Z14_maxdist = Z14_center.distanceTo(leftStart);
                angledRectangleCount++;
                break;
            case 14:
                left = dir.rotateLeftDegrees(90);
                leftStart = start.subtract(dir, avoidwidth).add(left, avoidwidth);
                leftEnd = end.add(dir, avoidwidth).add(left, avoidwidth);
                rightEnd = leftEnd.subtract(left, Float.sum(avoidwidth, avoidwidth));
                x1 = -leftEnd.x;
                y1 = -leftEnd.y;
                Z15_p21x = Float.sum(rightEnd.x, x1);
                Z15_p21y = Float.sum(rightEnd.y, y1);
                Z15_p41x = Float.sum(leftStart.x, x1);
                Z15_p41y = Float.sum(leftStart.y, y1);
                Z15_dotsection2 = -Float.sum(x1 * Z15_p21x, y1 * Z15_p21y);
                Z15_dotsection4 = -Float.sum(x1 * Z15_p41x, y1 * Z15_p41y);
                Z15_p21MagSquared = Float.sum(Z15_dotsection2, Float.sum(Z15_p21x * Z15_p21x, Z15_p21y * Z15_p21y));
                Z15_p41MagSquared = Float.sum(Z15_dotsection4, Float.sum(Z15_p41x * Z15_p41x, Z15_p41y * Z15_p41y));
                Z15_desire = desire;
                Z15_center = start.add(dir, speed * 0.5f);
                Z15_maxdist = Z15_center.distanceTo(leftStart);
                angledRectangleCount++;
                break;
            case 15:
                left = dir.rotateLeftDegrees(90);
                leftStart = start.subtract(dir, avoidwidth).add(left, avoidwidth);
                leftEnd = end.add(dir, avoidwidth).add(left, avoidwidth);
                rightEnd = leftEnd.subtract(left, Float.sum(avoidwidth, avoidwidth));
                x1 = -leftEnd.x;
                y1 = -leftEnd.y;
                Z16_p21x = Float.sum(rightEnd.x, x1);
                Z16_p21y = Float.sum(rightEnd.y, y1);
                Z16_p41x = Float.sum(leftStart.x, x1);
                Z16_p41y = Float.sum(leftStart.y, y1);
                Z16_dotsection2 = -Float.sum(x1 * Z16_p21x, y1 * Z16_p21y);
                Z16_dotsection4 = -Float.sum(x1 * Z16_p41x, y1 * Z16_p41y);
                Z16_p21MagSquared = Float.sum(Z16_dotsection2, Float.sum(Z16_p21x * Z16_p21x, Z16_p21y * Z16_p21y));
                Z16_p41MagSquared = Float.sum(Z16_dotsection4, Float.sum(Z16_p41x * Z16_p41x, Z16_p41y * Z16_p41y));
                Z16_desire = desire;
                Z16_center = start.add(dir, speed * 0.5f);
                Z16_maxdist = Z16_center.distanceTo(leftStart);
                angledRectangleCount++;
                break;
            case 16:
                left = dir.rotateLeftDegrees(90);
                leftStart = start.subtract(dir, avoidwidth).add(left, avoidwidth);
                leftEnd = end.add(dir, avoidwidth).add(left, avoidwidth);
                rightEnd = leftEnd.subtract(left, Float.sum(avoidwidth, avoidwidth));
                x1 = -leftEnd.x;
                y1 = -leftEnd.y;
                Z17_p21x = Float.sum(rightEnd.x, x1);
                Z17_p21y = Float.sum(rightEnd.y, y1);
                Z17_p41x = Float.sum(leftStart.x, x1);
                Z17_p41y = Float.sum(leftStart.y, y1);
                Z17_dotsection2 = -Float.sum(x1 * Z17_p21x, y1 * Z17_p21y);
                Z17_dotsection4 = -Float.sum(x1 * Z17_p41x, y1 * Z17_p41y);
                Z17_p21MagSquared = Float.sum(Z17_dotsection2, Float.sum(Z17_p21x * Z17_p21x, Z17_p21y * Z17_p21y));
                Z17_p41MagSquared = Float.sum(Z17_dotsection4, Float.sum(Z17_p41x * Z17_p41x, Z17_p41y * Z17_p41y));
                Z17_desire = desire;
                Z17_center = start.add(dir, speed * 0.5f);
                Z17_maxdist = Z17_center.distanceTo(leftStart);
                angledRectangleCount++;
                break;
            case 17:
                left = dir.rotateLeftDegrees(90);
                leftStart = start.subtract(dir, avoidwidth).add(left, avoidwidth);
                leftEnd = end.add(dir, avoidwidth).add(left, avoidwidth);
                rightEnd = leftEnd.subtract(left, Float.sum(avoidwidth, avoidwidth));
                x1 = -leftEnd.x;
                y1 = -leftEnd.y;
                Z18_p21x = Float.sum(rightEnd.x, x1);
                Z18_p21y = Float.sum(rightEnd.y, y1);
                Z18_p41x = Float.sum(leftStart.x, x1);
                Z18_p41y = Float.sum(leftStart.y, y1);
                Z18_dotsection2 = -Float.sum(x1 * Z18_p21x, y1 * Z18_p21y);
                Z18_dotsection4 = -Float.sum(x1 * Z18_p41x, y1 * Z18_p41y);
                Z18_p21MagSquared = Float.sum(Z18_dotsection2, Float.sum(Z18_p21x * Z18_p21x, Z18_p21y * Z18_p21y));
                Z18_p41MagSquared = Float.sum(Z18_dotsection4, Float.sum(Z18_p41x * Z18_p41x, Z18_p41y * Z18_p41y));
                Z18_desire = desire;
                Z18_center = start.add(dir, speed * 0.5f);
                Z18_maxdist = Z18_center.distanceTo(leftStart);
                angledRectangleCount++;
                break;
            case 18:
                left = dir.rotateLeftDegrees(90);
                leftStart = start.subtract(dir, avoidwidth).add(left, avoidwidth);
                leftEnd = end.add(dir, avoidwidth).add(left, avoidwidth);
                rightEnd = leftEnd.subtract(left, Float.sum(avoidwidth, avoidwidth));
                x1 = -leftEnd.x;
                y1 = -leftEnd.y;
                Z19_p21x = Float.sum(rightEnd.x, x1);
                Z19_p21y = Float.sum(rightEnd.y, y1);
                Z19_p41x = Float.sum(leftStart.x, x1);
                Z19_p41y = Float.sum(leftStart.y, y1);
                Z19_dotsection2 = -Float.sum(x1 * Z19_p21x, y1 * Z19_p21y);
                Z19_dotsection4 = -Float.sum(x1 * Z19_p41x, y1 * Z19_p41y);
                Z19_p21MagSquared = Float.sum(Z19_dotsection2, Float.sum(Z19_p21x * Z19_p21x, Z19_p21y * Z19_p21y));
                Z19_p41MagSquared = Float.sum(Z19_dotsection4, Float.sum(Z19_p41x * Z19_p41x, Z19_p41y * Z19_p41y));
                Z19_desire = desire;
                Z19_center = start.add(dir, speed * 0.5f);
                Z19_maxdist = Z19_center.distanceTo(leftStart);
                angledRectangleCount++;
                break;
            case 19:
                left = dir.rotateLeftDegrees(90);
                leftStart = start.subtract(dir, avoidwidth).add(left, avoidwidth);
                leftEnd = end.add(dir, avoidwidth).add(left, avoidwidth);
                rightEnd = leftEnd.subtract(left, Float.sum(avoidwidth, avoidwidth));
                x1 = -leftEnd.x;
                y1 = -leftEnd.y;
                Z20_p21x = Float.sum(rightEnd.x, x1);
                Z20_p21y = Float.sum(rightEnd.y, y1);
                Z20_p41x = Float.sum(leftStart.x, x1);
                Z20_p41y = Float.sum(leftStart.y, y1);
                Z20_dotsection2 = -Float.sum(x1 * Z20_p21x, y1 * Z20_p21y);
                Z20_dotsection4 = -Float.sum(x1 * Z20_p41x, y1 * Z20_p41y);
                Z20_p21MagSquared = Float.sum(Z20_dotsection2, Float.sum(Z20_p21x * Z20_p21x, Z20_p21y * Z20_p21y));
                Z20_p41MagSquared = Float.sum(Z20_dotsection4, Float.sum(Z20_p41x * Z20_p41x, Z20_p41y * Z20_p41y));
                Z20_desire = desire;
                Z20_center = start.add(dir, speed * 0.5f);
                Z20_maxdist = Z20_center.distanceTo(leftStart);
                angledRectangleCount++;
                break;
        }
    }

    //Adds a desire circle, various usages
    public static void addCircle(MapLocation center, float size, float desire) {
        switch (circleCount) {
            case 0:
                Z1c_desire = desire;
                Z1c_center = center;
                Z1c_size = size;
                circleCount++;
                break;
            case 1:
                Z2c_desire = desire;
                Z2c_center = center;
                Z2c_size = size;
                circleCount++;
                break;
            case 2:
                Z3c_desire = desire;
                Z3c_center = center;
                Z3c_size = size;
                circleCount++;
                break;
            case 3:
                Z4c_desire = desire;
                Z4c_center = center;
                Z4c_size = size;
                circleCount++;
                break;
            case 4:
                Z5c_desire = desire;
                Z5c_center = center;
                Z5c_size = size;
                circleCount++;
                break;
            case 5:
                Z6c_desire = desire;
                Z6c_center = center;
                Z6c_size = size;
                circleCount++;
                break;
            case 6:
                Z7c_desire = desire;
                Z7c_center = center;
                Z7c_size = size;
                circleCount++;
                break;
            case 7:
                Z8c_desire = desire;
                Z8c_center = center;
                Z8c_size = size;
                circleCount++;
                break;
            case 8:
                Z9c_desire = desire;
                Z9c_center = center;
                Z9c_size = size;
                circleCount++;
                break;
            case 9:
                Z10c_desire = desire;
                Z10c_center = center;
                Z10c_size = size;
                circleCount++;
                break;
            case 10:
                Z11c_desire = desire;
                Z11c_center = center;
                Z11c_size = size;
                circleCount++;
                break;
            case 11:
                Z12c_desire = desire;
                Z12c_center = center;
                Z12c_size = size;
                circleCount++;
                break;
            case 12:
                Z13c_desire = desire;
                Z13c_center = center;
                Z13c_size = size;
                circleCount++;
                break;
            case 13:
                Z14c_desire = desire;
                Z14c_center = center;
                Z14c_size = size;
                circleCount++;
                break;
            case 14:
                Z15c_desire = desire;
                Z15c_center = center;
                Z15c_size = size;
                circleCount++;
                break;
            case 15:
                Z16c_desire = desire;
                Z16c_center = center;
                Z16c_size = size;
                circleCount++;
                break;
            case 16:
                Z17c_desire = desire;
                Z17c_center = center;
                Z17c_size = size;
                circleCount++;
                break;
            case 17:
                Z18c_desire = desire;
                Z18c_center = center;
                Z18c_size = size;
                circleCount++;
                break;
            case 18:
                Z19c_desire = desire;
                Z19c_center = center;
                Z19c_size = size;
                circleCount++;
                break;
            case 19:
                Z20c_desire = desire;
                Z20c_center = center;
                Z20c_size = size;
                circleCount++;
                break;
        }
    }

    //Adds a desire circle with an extra force to or away from the center
    public static void addVectorCircle(MapLocation center, float size, float baseDesire, float distanceDesire) {
        switch (vectorCircleCount) {
            case 0:
                Z1vc_baseDesire = baseDesire + (distanceDesire * size);
                Z1vc_distanceDesire = -distanceDesire;
                Z1vc_center = center;
                Z1vc_size = size;
                vectorCircleCount++;
                break;
            case 1:
                Z2vc_baseDesire = baseDesire + (distanceDesire * size);
                Z2vc_distanceDesire = -distanceDesire;
                Z2vc_center = center;
                Z2vc_size = size;
                vectorCircleCount++;
                break;
            case 2:
                Z3vc_baseDesire = baseDesire + (distanceDesire * size);
                Z3vc_distanceDesire = -distanceDesire;
                Z3vc_center = center;
                Z3vc_size = size;
                vectorCircleCount++;
                break;
            case 3:
                Z4vc_baseDesire = baseDesire + (distanceDesire * size);
                Z4vc_distanceDesire = -distanceDesire;
                Z4vc_center = center;
                Z4vc_size = size;
                vectorCircleCount++;
                break;
            case 4:
                Z5vc_baseDesire = baseDesire + (distanceDesire * size);
                Z5vc_distanceDesire = -distanceDesire;
                Z5vc_center = center;
                Z5vc_size = size;
                vectorCircleCount++;
                break;
            case 5:
                Z6vc_baseDesire = baseDesire + (distanceDesire * size);
                Z6vc_distanceDesire = -distanceDesire;
                Z6vc_center = center;
                Z6vc_size = size;
                vectorCircleCount++;
                break;
            case 6:
                Z7vc_baseDesire = baseDesire + (distanceDesire * size);
                Z7vc_distanceDesire = -distanceDesire;
                Z7vc_center = center;
                Z7vc_size = size;
                vectorCircleCount++;
                break;
            case 7:
                Z8vc_baseDesire = baseDesire + (distanceDesire * size);
                Z8vc_distanceDesire = -distanceDesire;
                Z8vc_center = center;
                Z8vc_size = size;
                vectorCircleCount++;
                break;
            case 8:
                Z9vc_baseDesire = baseDesire + (distanceDesire * size);
                Z9vc_distanceDesire = -distanceDesire;
                Z9vc_center = center;
                Z9vc_size = size;
                vectorCircleCount++;
                break;
            case 9:
                Z10vc_baseDesire = baseDesire + (distanceDesire * size);
                Z10vc_distanceDesire = -distanceDesire;
                Z10vc_center = center;
                Z10vc_size = size;
                vectorCircleCount++;
                break;
            case 10:
                Z11vc_baseDesire = baseDesire + (distanceDesire * size);
                Z11vc_distanceDesire = -distanceDesire;
                Z11vc_center = center;
                Z11vc_size = size;
                vectorCircleCount++;
                break;
            case 11:
                Z12vc_baseDesire = baseDesire + (distanceDesire * size);
                Z12vc_distanceDesire = -distanceDesire;
                Z12vc_center = center;
                Z12vc_size = size;
                vectorCircleCount++;
                break;
            case 12:
                Z13vc_baseDesire = baseDesire + (distanceDesire * size);
                Z13vc_distanceDesire = -distanceDesire;
                Z13vc_center = center;
                Z13vc_size = size;
                vectorCircleCount++;
                break;
            case 13:
                Z14vc_baseDesire = baseDesire + (distanceDesire * size);
                Z14vc_distanceDesire = -distanceDesire;
                Z14vc_center = center;
                Z14vc_size = size;
                vectorCircleCount++;
                break;
            case 14:
                Z15vc_baseDesire = baseDesire + (distanceDesire * size);
                Z15vc_distanceDesire = -distanceDesire;
                Z15vc_center = center;
                Z15vc_size = size;
                vectorCircleCount++;
                break;
            case 15:
                Z16vc_baseDesire = baseDesire + (distanceDesire * size);
                Z16vc_distanceDesire = -distanceDesire;
                Z16vc_center = center;
                Z16vc_size = size;
                vectorCircleCount++;
                break;
            case 16:
                Z17vc_baseDesire = baseDesire + (distanceDesire * size);
                Z17vc_distanceDesire = -distanceDesire;
                Z17vc_center = center;
                Z17vc_size = size;
                vectorCircleCount++;
                break;
            case 17:
                Z18vc_baseDesire = baseDesire + (distanceDesire * size);
                Z18vc_distanceDesire = -distanceDesire;
                Z18vc_center = center;
                Z18vc_size = size;
                vectorCircleCount++;
                break;
            case 18:
                Z19vc_baseDesire = baseDesire + (distanceDesire * size);
                Z19vc_distanceDesire = -distanceDesire;
                Z19vc_center = center;
                Z19vc_size = size;
                vectorCircleCount++;
                break;
            case 19:
                Z20vc_baseDesire = baseDesire + (distanceDesire * size);
                Z20vc_distanceDesire = -distanceDesire;
                Z20vc_center = center;
                Z20vc_size = size;
                vectorCircleCount++;
                break;
        }
    }

    //Core of the bot. Our units evaluate different potential positions to walk to and evaluate these positions here using desire shapes
    //Using static variables to transmit values instead of parameters and return value for minor performance gain
    public static void getValuationSlot() {
        float locX = M.evaluateLoc.x;
        float locY = M.evaluateLoc.y;
        M.lastZoneValuation = M.evaluateLoc.distanceTo(M.finalMove) * M.moveVectorStr;  //Desire to move towards our main goal
        float test1;
        float test2;
        switch (angledRectangleCount) {
            default:
            case 20:
                if (M.evaluateLoc.isWithinDistance(Z20_center, Z20_maxdist)) {
                    test1 = Float.sum(locX * Z20_p21x, locY * Z20_p21y);
                    if (test1 >= Z20_dotsection2 && test1 <= Z20_p21MagSquared) {
                        test2 = Float.sum(locX * Z20_p41x, locY * Z20_p41y);
                        if (test2 >= Z20_dotsection4 && test2 <= Z20_p41MagSquared) {
                            M.lastZoneValuation = Float.sum(M.lastZoneValuation, Z20_desire);
                            if (M.lastZoneValuation < cutoff) return;
                        }
                    }
                }
            case 19:
                if (M.evaluateLoc.isWithinDistance(Z19_center, Z19_maxdist)) {
                    test1 = Float.sum(locX * Z19_p21x, locY * Z19_p21y);
                    if (test1 >= Z19_dotsection2 && test1 <= Z19_p21MagSquared) {
                        test2 = Float.sum(locX * Z19_p41x, locY * Z19_p41y);
                        if (test2 >= Z19_dotsection4 && test2 <= Z19_p41MagSquared) {
                            M.lastZoneValuation = Float.sum(M.lastZoneValuation, Z19_desire);
                            if (M.lastZoneValuation < cutoff) return;
                        }
                    }
                }
            case 18:
                if (M.evaluateLoc.isWithinDistance(Z18_center, Z18_maxdist)) {
                    test1 = Float.sum(locX * Z18_p21x, locY * Z18_p21y);
                    if (test1 >= Z18_dotsection2 && test1 <= Z18_p21MagSquared) {
                        test2 = Float.sum(locX * Z18_p41x, locY * Z18_p41y);
                        if (test2 >= Z18_dotsection4 && test2 <= Z18_p41MagSquared) {
                            M.lastZoneValuation = Float.sum(M.lastZoneValuation, Z18_desire);
                            if (M.lastZoneValuation < cutoff) return;
                        }
                    }
                }
            case 17:
                if (M.evaluateLoc.isWithinDistance(Z17_center, Z17_maxdist)) {
                    test1 = Float.sum(locX * Z17_p21x, locY * Z17_p21y);
                    if (test1 >= Z17_dotsection2 && test1 <= Z17_p21MagSquared) {
                        test2 = Float.sum(locX * Z17_p41x, locY * Z17_p41y);
                        if (test2 >= Z17_dotsection4 && test2 <= Z17_p41MagSquared) {
                            M.lastZoneValuation = Float.sum(M.lastZoneValuation, Z17_desire);
                            if (M.lastZoneValuation < cutoff) return;
                        }
                    }
                }
            case 16:
                if (M.evaluateLoc.isWithinDistance(Z16_center, Z16_maxdist)) {
                    test1 = Float.sum(locX * Z16_p21x, locY * Z16_p21y);
                    if (test1 >= Z16_dotsection2 && test1 <= Z16_p21MagSquared) {
                        test2 = Float.sum(locX * Z16_p41x, locY * Z16_p41y);
                        if (test2 >= Z16_dotsection4 && test2 <= Z16_p41MagSquared) {
                            M.lastZoneValuation = Float.sum(M.lastZoneValuation, Z16_desire);
                            if (M.lastZoneValuation < cutoff) return;
                        }
                    }
                }
            case 15:
                if (M.evaluateLoc.isWithinDistance(Z15_center, Z15_maxdist)) {
                    test1 = Float.sum(locX * Z15_p21x, locY * Z15_p21y);
                    if (test1 >= Z15_dotsection2 && test1 <= Z15_p21MagSquared) {
                        test2 = Float.sum(locX * Z15_p41x, locY * Z15_p41y);
                        if (test2 >= Z15_dotsection4 && test2 <= Z15_p41MagSquared) {
                            M.lastZoneValuation = Float.sum(M.lastZoneValuation, Z15_desire);
                            if (M.lastZoneValuation < cutoff) return;
                        }
                    }
                }
            case 14:
                if (M.evaluateLoc.isWithinDistance(Z14_center, Z14_maxdist)) {
                    test1 = Float.sum(locX * Z14_p21x, locY * Z14_p21y);
                    if (test1 >= Z14_dotsection2 && test1 <= Z14_p21MagSquared) {
                        test2 = Float.sum(locX * Z14_p41x, locY * Z14_p41y);
                        if (test2 >= Z14_dotsection4 && test2 <= Z14_p41MagSquared) {
                            M.lastZoneValuation = Float.sum(M.lastZoneValuation, Z14_desire);
                            if (M.lastZoneValuation < cutoff) return;
                        }
                    }
                }
            case 13:
                if (M.evaluateLoc.isWithinDistance(Z13_center, Z13_maxdist)) {
                    test1 = Float.sum(locX * Z13_p21x, locY * Z13_p21y);
                    if (test1 >= Z13_dotsection2 && test1 <= Z13_p21MagSquared) {
                        test2 = Float.sum(locX * Z13_p41x, locY * Z13_p41y);
                        if (test2 >= Z13_dotsection4 && test2 <= Z13_p41MagSquared) {
                            M.lastZoneValuation = Float.sum(M.lastZoneValuation, Z13_desire);
                            if (M.lastZoneValuation < cutoff) return;
                        }
                    }
                }
            case 12:
                if (M.evaluateLoc.isWithinDistance(Z12_center, Z12_maxdist)) {
                    test1 = Float.sum(locX * Z12_p21x, locY * Z12_p21y);
                    if (test1 >= Z12_dotsection2 && test1 <= Z12_p21MagSquared) {
                        test2 = Float.sum(locX * Z12_p41x, locY * Z12_p41y);
                        if (test2 >= Z12_dotsection4 && test2 <= Z12_p41MagSquared) {
                            M.lastZoneValuation = Float.sum(M.lastZoneValuation, Z12_desire);
                            if (M.lastZoneValuation < cutoff) return;
                        }
                    }
                }
            case 11:
                if (M.evaluateLoc.isWithinDistance(Z11_center, Z11_maxdist)) {
                    test1 = Float.sum(locX * Z11_p21x, locY * Z11_p21y);
                    if (test1 >= Z11_dotsection2 && test1 <= Z11_p21MagSquared) {
                        test2 = Float.sum(locX * Z11_p41x, locY * Z11_p41y);
                        if (test2 >= Z11_dotsection4 && test2 <= Z11_p41MagSquared) {
                            M.lastZoneValuation = Float.sum(M.lastZoneValuation, Z11_desire);
                            if (M.lastZoneValuation < cutoff) return;
                        }
                    }
                }
            case 10:
                if (M.evaluateLoc.isWithinDistance(Z10_center, Z10_maxdist)) {
                    test1 = Float.sum(locX * Z10_p21x, locY * Z10_p21y);
                    if (test1 >= Z10_dotsection2 && test1 <= Z10_p21MagSquared) {
                        test2 = Float.sum(locX * Z10_p41x, locY * Z10_p41y);
                        if (test2 >= Z10_dotsection4 && test2 <= Z10_p41MagSquared) {
                            M.lastZoneValuation = Float.sum(M.lastZoneValuation, Z10_desire);
                            if (M.lastZoneValuation < cutoff) return;
                        }
                    }
                }
            case 9:
                if (M.evaluateLoc.isWithinDistance(Z9_center, Z9_maxdist)) {
                    test1 = Float.sum(locX * Z9_p21x, locY * Z9_p21y);
                    if (test1 >= Z9_dotsection2 && test1 <= Z9_p21MagSquared) {
                        test2 = Float.sum(locX * Z9_p41x, locY * Z9_p41y);
                        if (test2 >= Z9_dotsection4 && test2 <= Z9_p41MagSquared) {
                            M.lastZoneValuation = Float.sum(M.lastZoneValuation, Z9_desire);
                            if (M.lastZoneValuation < cutoff) return;
                        }
                    }
                }
            case 8:
                if (M.evaluateLoc.isWithinDistance(Z8_center, Z8_maxdist)) {
                    test1 = Float.sum(locX * Z8_p21x, locY * Z8_p21y);
                    if (test1 >= Z8_dotsection2 && test1 <= Z8_p21MagSquared) {
                        test2 = Float.sum(locX * Z8_p41x, locY * Z8_p41y);
                        if (test2 >= Z8_dotsection4 && test2 <= Z8_p41MagSquared) {
                            M.lastZoneValuation = Float.sum(M.lastZoneValuation, Z8_desire);
                            if (M.lastZoneValuation < cutoff) return;
                        }
                    }
                }
            case 7:
                if (M.evaluateLoc.isWithinDistance(Z7_center, Z7_maxdist)) {
                    test1 = Float.sum(locX * Z7_p21x, locY * Z7_p21y);
                    if (test1 >= Z7_dotsection2 && test1 <= Z7_p21MagSquared) {
                        test2 = Float.sum(locX * Z7_p41x, locY * Z7_p41y);
                        if (test2 >= Z7_dotsection4 && test2 <= Z7_p41MagSquared) {
                            M.lastZoneValuation = Float.sum(M.lastZoneValuation, Z7_desire);
                            if (M.lastZoneValuation < cutoff) return;
                        }
                    }
                }
            case 6:
                if (M.evaluateLoc.isWithinDistance(Z6_center, Z6_maxdist)) {
                    test1 = Float.sum(locX * Z6_p21x, locY * Z6_p21y);
                    if (test1 >= Z6_dotsection2 && test1 <= Z6_p21MagSquared) {
                        test2 = Float.sum(locX * Z6_p41x, locY * Z6_p41y);
                        if (test2 >= Z6_dotsection4 && test2 <= Z6_p41MagSquared) {
                            M.lastZoneValuation = Float.sum(M.lastZoneValuation, Z6_desire);
                            if (M.lastZoneValuation < cutoff) return;
                        }
                    }
                }
            case 5:
                if (M.evaluateLoc.isWithinDistance(Z5_center, Z5_maxdist)) {
                    test1 = Float.sum(locX * Z5_p21x, locY * Z5_p21y);
                    if (test1 >= Z5_dotsection2 && test1 <= Z5_p21MagSquared) {
                        test2 = Float.sum(locX * Z5_p41x, locY * Z5_p41y);
                        if (test2 >= Z5_dotsection4 && test2 <= Z5_p41MagSquared) {
                            M.lastZoneValuation = Float.sum(M.lastZoneValuation, Z5_desire);
                            if (M.lastZoneValuation < cutoff) return;
                        }
                    }
                }
            case 4:
                if (M.evaluateLoc.isWithinDistance(Z4_center, Z4_maxdist)) {
                    test1 = Float.sum(locX * Z4_p21x, locY * Z4_p21y);
                    if (test1 >= Z4_dotsection2 && test1 <= Z4_p21MagSquared) {
                        test2 = Float.sum(locX * Z4_p41x, locY * Z4_p41y);
                        if (test2 >= Z4_dotsection4 && test2 <= Z4_p41MagSquared) {
                            M.lastZoneValuation = Float.sum(M.lastZoneValuation, Z4_desire);
                            if (M.lastZoneValuation < cutoff) return;
                        }
                    }
                }
            case 3:
                if (M.evaluateLoc.isWithinDistance(Z3_center, Z3_maxdist)) {
                    test1 = Float.sum(locX * Z3_p21x, locY * Z3_p21y);
                    if (test1 >= Z3_dotsection2 && test1 <= Z3_p21MagSquared) {
                        test2 = Float.sum(locX * Z3_p41x, locY * Z3_p41y);
                        if (test2 >= Z3_dotsection4 && test2 <= Z3_p41MagSquared) {
                            M.lastZoneValuation = Float.sum(M.lastZoneValuation, Z3_desire);
                            if (M.lastZoneValuation < cutoff) return;
                        }
                    }
                }
            case 2:
                if (M.evaluateLoc.isWithinDistance(Z2_center, Z2_maxdist)) {
                    test1 = Float.sum(locX * Z2_p21x, locY * Z2_p21y);
                    if (test1 >= Z2_dotsection2 && test1 <= Z2_p21MagSquared) {
                        test2 = Float.sum(locX * Z2_p41x, locY * Z2_p41y);
                        if (test2 >= Z2_dotsection4 && test2 <= Z2_p41MagSquared) {
                            M.lastZoneValuation = Float.sum(M.lastZoneValuation, Z2_desire);
                            if (M.lastZoneValuation < cutoff) return;
                        }
                    }
                }
            case 1:
                if (M.evaluateLoc.isWithinDistance(Z1_center, Z1_maxdist)) {
                    test1 = Float.sum(locX * Z1_p21x, locY * Z1_p21y);
                    if (test1 >= Z1_dotsection2 && test1 <= Z1_p21MagSquared) {
                        test2 = Float.sum(locX * Z1_p41x, locY * Z1_p41y);
                        if (test2 >= Z1_dotsection4 && test2 <= Z1_p41MagSquared) {
                            M.lastZoneValuation = Float.sum(M.lastZoneValuation, Z1_desire);
                            if (M.lastZoneValuation < cutoff) return;
                        }
                    }
                }
            case 0:
        }
        switch (circleCount) {
            case 20:
                if (M.evaluateLoc.isWithinDistance(Z20c_center, Z20c_size)) {
                    M.lastZoneValuation = Float.sum(M.lastZoneValuation, Z20c_desire);
                    if (M.lastZoneValuation < cutoff) return;
                }
            case 19:
                if (M.evaluateLoc.isWithinDistance(Z19c_center, Z19c_size)) {
                    M.lastZoneValuation = Float.sum(M.lastZoneValuation, Z19c_desire);
                    if (M.lastZoneValuation < cutoff) return;
                }
            case 18:
                if (M.evaluateLoc.isWithinDistance(Z18c_center, Z18c_size)) {
                    M.lastZoneValuation = Float.sum(M.lastZoneValuation, Z18c_desire);
                    if (M.lastZoneValuation < cutoff) return;
                }
            case 17:
                if (M.evaluateLoc.isWithinDistance(Z17c_center, Z17c_size)) {
                    M.lastZoneValuation = Float.sum(M.lastZoneValuation, Z17c_desire);
                    if (M.lastZoneValuation < cutoff) return;
                }
            case 16:
                if (M.evaluateLoc.isWithinDistance(Z16c_center, Z16c_size)) {
                    M.lastZoneValuation = Float.sum(M.lastZoneValuation, Z16c_desire);
                    if (M.lastZoneValuation < cutoff) return;
                }
            case 15:
                if (M.evaluateLoc.isWithinDistance(Z15c_center, Z15c_size)) {
                    M.lastZoneValuation = Float.sum(M.lastZoneValuation, Z15c_desire);
                    if (M.lastZoneValuation < cutoff) return;
                }
            case 14:
                if (M.evaluateLoc.isWithinDistance(Z14c_center, Z14c_size)) {
                    M.lastZoneValuation = Float.sum(M.lastZoneValuation, Z14c_desire);
                    if (M.lastZoneValuation < cutoff) return;
                }
            case 13:
                if (M.evaluateLoc.isWithinDistance(Z13c_center, Z13c_size)) {
                    M.lastZoneValuation = Float.sum(M.lastZoneValuation, Z13c_desire);
                    if (M.lastZoneValuation < cutoff) return;
                }
            case 12:
                if (M.evaluateLoc.isWithinDistance(Z12c_center, Z12c_size)) {
                    M.lastZoneValuation = Float.sum(M.lastZoneValuation, Z12c_desire);
                    if (M.lastZoneValuation < cutoff) return;
                }
            case 11:
                if (M.evaluateLoc.isWithinDistance(Z11c_center, Z11c_size)) {
                    M.lastZoneValuation = Float.sum(M.lastZoneValuation, Z11c_desire);
                    if (M.lastZoneValuation < cutoff) return;
                }
            case 10:
                if (M.evaluateLoc.isWithinDistance(Z10c_center, Z10c_size)) {
                    M.lastZoneValuation = Float.sum(M.lastZoneValuation, Z10c_desire);
                    if (M.lastZoneValuation < cutoff) return;
                }
            case 9:
                if (M.evaluateLoc.isWithinDistance(Z9c_center, Z9c_size)) {
                    M.lastZoneValuation = Float.sum(M.lastZoneValuation, Z9c_desire);
                    if (M.lastZoneValuation < cutoff) return;
                }
            case 8:
                if (M.evaluateLoc.isWithinDistance(Z8c_center, Z8c_size)) {
                    M.lastZoneValuation = Float.sum(M.lastZoneValuation, Z8c_desire);
                    if (M.lastZoneValuation < cutoff) return;
                }
            case 7:
                if (M.evaluateLoc.isWithinDistance(Z7c_center, Z7c_size)) {
                    M.lastZoneValuation = Float.sum(M.lastZoneValuation, Z7c_desire);
                    if (M.lastZoneValuation < cutoff) return;
                }
            case 6:
                if (M.evaluateLoc.isWithinDistance(Z6c_center, Z6c_size)) {
                    M.lastZoneValuation = Float.sum(M.lastZoneValuation, Z6c_desire);
                    if (M.lastZoneValuation < cutoff) return;
                }
            case 5:
                if (M.evaluateLoc.isWithinDistance(Z5c_center, Z5c_size)) {
                    M.lastZoneValuation = Float.sum(M.lastZoneValuation, Z5c_desire);
                    if (M.lastZoneValuation < cutoff) return;
                }
            case 4:
                if (M.evaluateLoc.isWithinDistance(Z4c_center, Z4c_size)) {
                    M.lastZoneValuation = Float.sum(M.lastZoneValuation, Z4c_desire);
                    if (M.lastZoneValuation < cutoff) return;
                }
            case 3:
                if (M.evaluateLoc.isWithinDistance(Z3c_center, Z3c_size)) {
                    M.lastZoneValuation = Float.sum(M.lastZoneValuation, Z3c_desire);
                }
            case 2:
                if (M.evaluateLoc.isWithinDistance(Z2c_center, Z2c_size)) {
                    M.lastZoneValuation = Float.sum(M.lastZoneValuation, Z2c_desire);
                }
            case 1:
                if (M.evaluateLoc.isWithinDistance(Z1c_center, Z1c_size)) {
                    M.lastZoneValuation = Float.sum(M.lastZoneValuation, Z1c_desire);
                }
            case 0:
        }
        switch (vectorCircleCount) {
            case 20:
                if (M.evaluateLoc.isWithinDistance(Z20vc_center, Z20vc_size)) {
                    M.lastZoneValuation = Float.sum(M.lastZoneValuation, Float.sum(Z20vc_baseDesire, M.evaluateLoc.distanceTo(Z20vc_center) * Z20vc_distanceDesire));
                    if (M.lastZoneValuation < cutoff) return;
                }
            case 19:
                if (M.evaluateLoc.isWithinDistance(Z19vc_center, Z19vc_size)) {
                    M.lastZoneValuation = Float.sum(M.lastZoneValuation, Float.sum(Z19vc_baseDesire, M.evaluateLoc.distanceTo(Z19vc_center) * Z19vc_distanceDesire));
                    if (M.lastZoneValuation < cutoff) return;
                }
            case 18:
                if (M.evaluateLoc.isWithinDistance(Z18vc_center, Z18vc_size)) {
                    M.lastZoneValuation = Float.sum(M.lastZoneValuation, Float.sum(Z18vc_baseDesire, M.evaluateLoc.distanceTo(Z18vc_center) * Z18vc_distanceDesire));
                    if (M.lastZoneValuation < cutoff) return;
                }
            case 17:
                if (M.evaluateLoc.isWithinDistance(Z17vc_center, Z17vc_size)) {
                    M.lastZoneValuation = Float.sum(M.lastZoneValuation, Float.sum(Z17vc_baseDesire, M.evaluateLoc.distanceTo(Z17vc_center) * Z17vc_distanceDesire));
                    if (M.lastZoneValuation < cutoff) return;
                }
            case 16:
                if (M.evaluateLoc.isWithinDistance(Z16vc_center, Z16vc_size)) {
                    M.lastZoneValuation = Float.sum(M.lastZoneValuation, Float.sum(Z16vc_baseDesire, M.evaluateLoc.distanceTo(Z16vc_center) * Z16vc_distanceDesire));
                    if (M.lastZoneValuation < cutoff) return;
                }
            case 15:
                if (M.evaluateLoc.isWithinDistance(Z15vc_center, Z15vc_size)) {
                    M.lastZoneValuation = Float.sum(M.lastZoneValuation, Float.sum(Z15vc_baseDesire, M.evaluateLoc.distanceTo(Z15vc_center) * Z15vc_distanceDesire));
                    if (M.lastZoneValuation < cutoff) return;
                }
            case 14:
                if (M.evaluateLoc.isWithinDistance(Z14vc_center, Z14vc_size)) {
                    M.lastZoneValuation = Float.sum(M.lastZoneValuation, Float.sum(Z14vc_baseDesire, M.evaluateLoc.distanceTo(Z14vc_center) * Z14vc_distanceDesire));
                    if (M.lastZoneValuation < cutoff) return;
                }
            case 13:
                if (M.evaluateLoc.isWithinDistance(Z13vc_center, Z13vc_size)) {
                    M.lastZoneValuation = Float.sum(M.lastZoneValuation, Float.sum(Z13vc_baseDesire, M.evaluateLoc.distanceTo(Z13vc_center) * Z13vc_distanceDesire));
                    if (M.lastZoneValuation < cutoff) return;
                }
            case 12:
                if (M.evaluateLoc.isWithinDistance(Z12vc_center, Z12vc_size)) {
                    M.lastZoneValuation = Float.sum(M.lastZoneValuation, Float.sum(Z12vc_baseDesire, M.evaluateLoc.distanceTo(Z12vc_center) * Z12vc_distanceDesire));
                    if (M.lastZoneValuation < cutoff) return;
                }
            case 11:
                if (M.evaluateLoc.isWithinDistance(Z11vc_center, Z11vc_size)) {
                    M.lastZoneValuation = Float.sum(M.lastZoneValuation, Float.sum(Z11vc_baseDesire, M.evaluateLoc.distanceTo(Z11vc_center) * Z11vc_distanceDesire));
                    if (M.lastZoneValuation < cutoff) return;
                }
            case 10:
                if (M.evaluateLoc.isWithinDistance(Z10vc_center, Z10vc_size)) {
                    M.lastZoneValuation = Float.sum(M.lastZoneValuation, Float.sum(Z10vc_baseDesire, M.evaluateLoc.distanceTo(Z10vc_center) * Z10vc_distanceDesire));
                    if (M.lastZoneValuation < cutoff) return;
                }
            case 9:
                if (M.evaluateLoc.isWithinDistance(Z9vc_center, Z9vc_size)) {
                    M.lastZoneValuation = Float.sum(M.lastZoneValuation, Float.sum(Z9vc_baseDesire, M.evaluateLoc.distanceTo(Z9vc_center) * Z9vc_distanceDesire));
                    if (M.lastZoneValuation < cutoff) return;
                }
            case 8:
                if (M.evaluateLoc.isWithinDistance(Z8vc_center, Z8vc_size)) {
                    M.lastZoneValuation = Float.sum(M.lastZoneValuation, Float.sum(Z8vc_baseDesire, M.evaluateLoc.distanceTo(Z8vc_center) * Z8vc_distanceDesire));
                    if (M.lastZoneValuation < cutoff) return;
                }
            case 7:
                if (M.evaluateLoc.isWithinDistance(Z7vc_center, Z7vc_size)) {
                    M.lastZoneValuation = Float.sum(M.lastZoneValuation, Float.sum(Z7vc_baseDesire, M.evaluateLoc.distanceTo(Z7vc_center) * Z7vc_distanceDesire));
                    if (M.lastZoneValuation < cutoff) return;
                }
            case 6:
                if (M.evaluateLoc.isWithinDistance(Z6vc_center, Z6vc_size)) {
                    M.lastZoneValuation = Float.sum(M.lastZoneValuation, Float.sum(Z6vc_baseDesire, M.evaluateLoc.distanceTo(Z6vc_center) * Z6vc_distanceDesire));
                    if (M.lastZoneValuation < cutoff) return;
                }
            case 5:
                if (M.evaluateLoc.isWithinDistance(Z5vc_center, Z5vc_size)) {
                    M.lastZoneValuation = Float.sum(M.lastZoneValuation, Float.sum(Z5vc_baseDesire, M.evaluateLoc.distanceTo(Z5vc_center) * Z5vc_distanceDesire));
                    if (M.lastZoneValuation < cutoff) return;
                }
            case 4:
                if (M.evaluateLoc.isWithinDistance(Z4vc_center, Z4vc_size)) {
                    M.lastZoneValuation = Float.sum(M.lastZoneValuation, Float.sum(Z4vc_baseDesire, M.evaluateLoc.distanceTo(Z4vc_center) * Z4vc_distanceDesire));
                    if (M.lastZoneValuation < cutoff) return;
                }
            case 3:
                if (M.evaluateLoc.isWithinDistance(Z3vc_center, Z3vc_size)) {
                    M.lastZoneValuation = Float.sum(M.lastZoneValuation, Float.sum(Z3vc_baseDesire, M.evaluateLoc.distanceTo(Z3vc_center) * Z3vc_distanceDesire));
                }
            case 2:
                if (M.evaluateLoc.isWithinDistance(Z2vc_center, Z2vc_size)) {
                    M.lastZoneValuation = Float.sum(M.lastZoneValuation, Float.sum(Z2vc_baseDesire, M.evaluateLoc.distanceTo(Z2vc_center) * Z2vc_distanceDesire));
                }
            case 1:
                if (M.evaluateLoc.isWithinDistance(Z1vc_center, Z1vc_size)) {
                    M.lastZoneValuation = Float.sum(M.lastZoneValuation, Float.sum(Z1vc_baseDesire, M.evaluateLoc.distanceTo(Z1vc_center) * Z1vc_distanceDesire));
                }
            case 0:
        }
        //Rarely used, should be optimized the same way if this becomes more common
        for (int i = M.squareIndexMinusOne; i >= 0; i--) {
            ZoneSquare zone = M.squares[i];
            if (zone.left < locX && locX < zone.right && locY < zone.top && locY > zone.bot) {
                M.lastZoneValuation += zone.desire;
            }
        }
    }

    public static int angledRectangleCount;
    public static int vectorCircleCount;
    public static float cutoff = C.CUTOFFZONEEVALUTION;
    private static float Z1_p21x;
    private static float Z1_p21y;
    private static float Z1_p41x;
    private static float Z1_p41y;
    private static float Z1_p21MagSquared;
    private static float Z1_p41MagSquared;
    private static float Z1_desire;
    private static float Z1_dotsection2;
    private static float Z1_dotsection4;
    private static MapLocation Z1_center;
    private static float Z1_maxdist;
    private static float Z2_p21x;
    private static float Z2_p21y;
    private static float Z2_p41x;
    private static float Z2_p41y;
    private static float Z2_p21MagSquared;
    private static float Z2_p41MagSquared;
    private static float Z2_desire;
    private static float Z2_dotsection2;
    private static float Z2_dotsection4;
    private static MapLocation Z2_center;
    private static float Z2_maxdist;
    private static float Z3_p21x;
    private static float Z3_p21y;
    private static float Z3_p41x;
    private static float Z3_p41y;
    private static float Z3_p21MagSquared;
    private static float Z3_p41MagSquared;
    private static float Z3_desire;
    private static float Z3_dotsection2;
    private static float Z3_dotsection4;
    private static MapLocation Z3_center;
    private static float Z3_maxdist;
    private static float Z4_p21x;
    private static float Z4_p21y;
    private static float Z4_p41x;
    private static float Z4_p41y;
    private static float Z4_p21MagSquared;
    private static float Z4_p41MagSquared;
    private static float Z4_desire;
    private static float Z4_dotsection2;
    private static float Z4_dotsection4;
    private static MapLocation Z4_center;
    private static float Z4_maxdist;
    private static float Z5_p21x;
    private static float Z5_p21y;
    private static float Z5_p41x;
    private static float Z5_p41y;
    private static float Z5_p21MagSquared;
    private static float Z5_p41MagSquared;
    private static float Z5_desire;
    private static float Z5_dotsection2;
    private static float Z5_dotsection4;
    private static MapLocation Z5_center;
    private static float Z5_maxdist;
    private static float Z6_p21x;
    private static float Z6_p21y;
    private static float Z6_p41x;
    private static float Z6_p41y;
    private static float Z6_p21MagSquared;
    private static float Z6_p41MagSquared;
    private static float Z6_desire;
    private static float Z6_dotsection2;
    private static float Z6_dotsection4;
    private static MapLocation Z6_center;
    private static float Z6_maxdist;
    private static float Z7_p21x;
    private static float Z7_p21y;
    private static float Z7_p41x;
    private static float Z7_p41y;
    private static float Z7_p21MagSquared;
    private static float Z7_p41MagSquared;
    private static float Z7_desire;
    private static float Z7_dotsection2;
    private static float Z7_dotsection4;
    private static MapLocation Z7_center;
    private static float Z7_maxdist;
    private static float Z8_p21x;
    private static float Z8_p21y;
    private static float Z8_p41x;
    private static float Z8_p41y;
    private static float Z8_p21MagSquared;
    private static float Z8_p41MagSquared;
    private static float Z8_desire;
    private static float Z8_dotsection2;
    private static float Z8_dotsection4;
    private static MapLocation Z8_center;
    private static float Z8_maxdist;
    private static float Z9_p21x;
    private static float Z9_p21y;
    private static float Z9_p41x;
    private static float Z9_p41y;
    private static float Z9_p21MagSquared;
    private static float Z9_p41MagSquared;
    private static float Z9_desire;
    private static float Z9_dotsection2;
    private static float Z9_dotsection4;
    private static MapLocation Z9_center;
    private static float Z9_maxdist;
    private static float Z10_p21x;
    private static float Z10_p21y;
    private static float Z10_p41x;
    private static float Z10_p41y;
    private static float Z10_p21MagSquared;
    private static float Z10_p41MagSquared;
    private static float Z10_desire;
    private static float Z10_dotsection2;
    private static float Z10_dotsection4;
    private static MapLocation Z10_center;
    private static float Z10_maxdist;
    private static float Z11_p21x;
    private static float Z11_p21y;
    private static float Z11_p41x;
    private static float Z11_p41y;
    private static float Z11_p21MagSquared;
    private static float Z11_p41MagSquared;
    private static float Z11_desire;
    private static float Z11_dotsection2;
    private static float Z11_dotsection4;
    private static MapLocation Z11_center;
    private static float Z11_maxdist;
    private static float Z12_p21x;
    private static float Z12_p21y;
    private static float Z12_p41x;
    private static float Z12_p41y;
    private static float Z12_p21MagSquared;
    private static float Z12_p41MagSquared;
    private static float Z12_desire;
    private static float Z12_dotsection2;
    private static float Z12_dotsection4;
    private static MapLocation Z12_center;
    private static float Z12_maxdist;
    private static float Z13_p21x;
    private static float Z13_p21y;
    private static float Z13_p41x;
    private static float Z13_p41y;
    private static float Z13_p21MagSquared;
    private static float Z13_p41MagSquared;
    private static float Z13_desire;
    private static float Z13_dotsection2;
    private static float Z13_dotsection4;
    private static MapLocation Z13_center;
    private static float Z13_maxdist;
    private static float Z14_p21x;
    private static float Z14_p21y;
    private static float Z14_p41x;
    private static float Z14_p41y;
    private static float Z14_p21MagSquared;
    private static float Z14_p41MagSquared;
    private static float Z14_desire;
    private static float Z14_dotsection2;
    private static float Z14_dotsection4;
    private static MapLocation Z14_center;
    private static float Z14_maxdist;
    private static float Z15_p21x;
    private static float Z15_p21y;
    private static float Z15_p41x;
    private static float Z15_p41y;
    private static float Z15_p21MagSquared;
    private static float Z15_p41MagSquared;
    private static float Z15_desire;
    private static float Z15_dotsection2;
    private static float Z15_dotsection4;
    private static MapLocation Z15_center;
    private static float Z15_maxdist;
    private static float Z16_p21x;
    private static float Z16_p21y;
    private static float Z16_p41x;
    private static float Z16_p41y;
    private static float Z16_p21MagSquared;
    private static float Z16_p41MagSquared;
    private static float Z16_desire;
    private static float Z16_dotsection2;
    private static float Z16_dotsection4;
    private static MapLocation Z16_center;
    private static float Z16_maxdist;
    private static float Z17_p21x;
    private static float Z17_p21y;
    private static float Z17_p41x;
    private static float Z17_p41y;
    private static float Z17_p21MagSquared;
    private static float Z17_p41MagSquared;
    private static float Z17_desire;
    private static float Z17_dotsection2;
    private static float Z17_dotsection4;
    private static MapLocation Z17_center;
    private static float Z17_maxdist;
    private static float Z18_p21x;
    private static float Z18_p21y;
    private static float Z18_p41x;
    private static float Z18_p41y;
    private static float Z18_p21MagSquared;
    private static float Z18_p41MagSquared;
    private static float Z18_desire;
    private static float Z18_dotsection2;
    private static float Z18_dotsection4;
    private static MapLocation Z18_center;
    private static float Z18_maxdist;
    private static float Z19_p21x;
    private static float Z19_p21y;
    private static float Z19_p41x;
    private static float Z19_p41y;
    private static float Z19_p21MagSquared;
    private static float Z19_p41MagSquared;
    private static float Z19_desire;
    private static float Z19_dotsection2;
    private static float Z19_dotsection4;
    private static MapLocation Z19_center;
    private static float Z19_maxdist;
    private static float Z20_p21x;
    private static float Z20_p21y;
    private static float Z20_p41x;
    private static float Z20_p41y;
    private static float Z20_p21MagSquared;
    private static float Z20_p41MagSquared;
    private static float Z20_desire;
    private static float Z20_dotsection2;
    private static float Z20_dotsection4;
    private static MapLocation Z20_center;
    private static float Z20_maxdist;
    public static int circleCount;
    private static float Z1c_desire;
    private static float Z1c_size;
    private static MapLocation Z1c_center;
    private static float Z2c_desire;
    private static float Z2c_size;
    private static MapLocation Z2c_center;
    private static float Z3c_desire;
    private static float Z3c_size;
    private static MapLocation Z3c_center;
    private static float Z4c_desire;
    private static float Z4c_size;
    private static MapLocation Z4c_center;
    private static float Z5c_desire;
    private static float Z5c_size;
    private static MapLocation Z5c_center;
    private static float Z6c_desire;
    private static float Z6c_size;
    private static MapLocation Z6c_center;
    private static float Z7c_desire;
    private static float Z7c_size;
    private static MapLocation Z7c_center;
    private static float Z8c_desire;
    private static float Z8c_size;
    private static MapLocation Z8c_center;
    private static float Z9c_desire;
    private static float Z9c_size;
    private static MapLocation Z9c_center;
    private static float Z10c_desire;
    private static float Z10c_size;
    private static MapLocation Z10c_center;
    private static float Z11c_desire;
    private static float Z11c_size;
    private static MapLocation Z11c_center;
    private static float Z12c_desire;
    private static float Z12c_size;
    private static MapLocation Z12c_center;
    private static float Z13c_desire;
    private static float Z13c_size;
    private static MapLocation Z13c_center;
    private static float Z14c_desire;
    private static float Z14c_size;
    private static MapLocation Z14c_center;
    private static float Z15c_desire;
    private static float Z15c_size;
    private static MapLocation Z15c_center;
    private static float Z16c_desire;
    private static float Z16c_size;
    private static MapLocation Z16c_center;
    private static float Z17c_desire;
    private static float Z17c_size;
    private static MapLocation Z17c_center;
    private static float Z18c_desire;
    private static float Z18c_size;
    private static MapLocation Z18c_center;
    private static float Z19c_desire;
    private static float Z19c_size;
    private static MapLocation Z19c_center;
    private static float Z20c_desire;
    private static float Z20c_size;
    private static MapLocation Z20c_center;
    private static float Z1vc_baseDesire;
    private static float Z1vc_distanceDesire;
    private static float Z1vc_size;
    private static MapLocation Z1vc_center;
    private static float Z2vc_baseDesire;
    private static float Z2vc_distanceDesire;
    private static float Z2vc_size;
    private static MapLocation Z2vc_center;
    private static float Z3vc_baseDesire;
    private static float Z3vc_distanceDesire;
    private static float Z3vc_size;
    private static MapLocation Z3vc_center;
    private static float Z4vc_baseDesire;
    private static float Z4vc_distanceDesire;
    private static float Z4vc_size;
    private static MapLocation Z4vc_center;
    private static float Z5vc_baseDesire;
    private static float Z5vc_distanceDesire;
    private static float Z5vc_size;
    private static MapLocation Z5vc_center;
    private static float Z6vc_baseDesire;
    private static float Z6vc_distanceDesire;
    private static float Z6vc_size;
    private static MapLocation Z6vc_center;
    private static float Z7vc_baseDesire;
    private static float Z7vc_distanceDesire;
    private static float Z7vc_size;
    private static MapLocation Z7vc_center;
    private static float Z8vc_baseDesire;
    private static float Z8vc_distanceDesire;
    private static float Z8vc_size;
    private static MapLocation Z8vc_center;
    private static float Z9vc_baseDesire;
    private static float Z9vc_distanceDesire;
    private static float Z9vc_size;
    private static MapLocation Z9vc_center;
    private static float Z10vc_baseDesire;
    private static float Z10vc_distanceDesire;
    private static float Z10vc_size;
    private static MapLocation Z10vc_center;
    private static float Z11vc_baseDesire;
    private static float Z11vc_distanceDesire;
    private static float Z11vc_size;
    private static MapLocation Z11vc_center;
    private static float Z12vc_baseDesire;
    private static float Z12vc_distanceDesire;
    private static float Z12vc_size;
    private static MapLocation Z12vc_center;
    private static float Z13vc_baseDesire;
    private static float Z13vc_distanceDesire;
    private static float Z13vc_size;
    private static MapLocation Z13vc_center;
    private static float Z14vc_baseDesire;
    private static float Z14vc_distanceDesire;
    private static float Z14vc_size;
    private static MapLocation Z14vc_center;
    private static float Z15vc_baseDesire;
    private static float Z15vc_distanceDesire;
    private static float Z15vc_size;
    private static MapLocation Z15vc_center;
    private static float Z16vc_baseDesire;
    private static float Z16vc_distanceDesire;
    private static float Z16vc_size;
    private static MapLocation Z16vc_center;
    private static float Z17vc_baseDesire;
    private static float Z17vc_distanceDesire;
    private static float Z17vc_size;
    private static MapLocation Z17vc_center;
    private static float Z18vc_baseDesire;
    private static float Z18vc_distanceDesire;
    private static float Z18vc_size;
    private static MapLocation Z18vc_center;
    private static float Z19vc_baseDesire;
    private static float Z19vc_distanceDesire;
    private static float Z19vc_size;
    private static MapLocation Z19vc_center;
    private static float Z20vc_baseDesire;
    private static float Z20vc_distanceDesire;
    private static float Z20vc_size;
    private static MapLocation Z20vc_center;

}